<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Klondike</title>
<style>
html, body, canvas {
    box-sizing: border-box;
}

html, body {
    width: 100vw;
    height: 100vh;
    margin: 0;
    padding: 0;
}

body {
	background-color: rgb(0, 80, 0);
}

canvas {
	display: block;
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
/**
 * Globals
 */

const cards = [];
['club', 'diamond', 'heart', 'spade'].forEach(suit => {
	for (let i = 1; i <= 13; i++) {
		cards.push(`${suit}_${i}`);
	}
});

const image_names = ['back_red', 'card_base', ...cards];
let image_queue = image_names.length;
const images = {};
const images_canvas = {};

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let width;
let height;
let card_width;
let card_height;
let card_spacing;
let card_step;
let start_x;

let needs_redraw = true;

const deck = [];
const stock = [];
const waste = [];
const foundations = [[], [], [], []];
const piles = [[], [], [], [], [], [], []];

/**
 * Init
 */

recalculate_sizes();

window.addEventListener("resize", function () {
	recalculate_sizes();
	image_names.forEach(redraw_image);
	needs_redraw = true;

	if (!image_queue) {
		window.requestAnimationFrame(draw);
	}
});

window.addEventListener("keydown", function (e) {
	if (e.altKey && e.code === "KeyN") {
		new_game();
		window.requestAnimationFrame(draw);
	}
});

image_names.forEach(name => {
	images[name] = new Image();
	images[name].src = `cards/${name}.png`;
	images[name].addEventListener('load', () => {
		--image_queue;
		redraw_image(name);

		if (!image_queue) {
			new_game();
			window.requestAnimationFrame(draw);
		}
	});
	images[name].addEventListener('error', (er) => {
		throw er;
	});
});

cards.forEach(name => {
	deck.push({
		name: name,
		suit: name.split('_')[0],
		number: name.split('_')[1],
		turnedup: false,
	});
});

/**
 * Functions
 */

function new_game()
{
	while (stock.length) {
		deck.push(stock.pop());
	}

	while (waste.length) {
		deck.push(waste.pop());
	}

	for (let i = 0; i < piles.length; i++) {
		while (piles[i].length) {
			deck.push(piles[i].pop());
		}
	}

	for (let i = 0; i < foundations.length; i++) {
		while (foundations[i].length) {
			deck.push(foundations[i].pop());
		}
	}

	deck.forEach(card => card.turnedup = false);

	for (let i = 0; i < piles.length; i++) {
		for (let j = i; j < piles.length; j++) {
			const r = Math.floor(Math.random() * deck.length);
			const card = deck.splice(r, 1)[0];
			piles[j].push(card);
		}

		piles[i][i].turnedup = true;
	}

	while (deck.length) {
		stock.push(deck.pop());
	}
}

function recalculate_sizes() {
	width = document.body.clientWidth;
	height = document.body.clientHeight;
	canvas.width = width;
	canvas.height = height;

	const factor_spacing = 0.1;
	const factor_width = 0.69;
	const factor_height = 1.45;
	const factor_step_max = 0.165;

	card_width = Math.round(width / 7 * (1 - factor_spacing));
	card_height = Math.round(card_width * factor_height);
	card_spacing = Math.round(card_width * (factor_spacing / 2));
	card_step = Math.round(card_height * factor_step_max);

	const max_card_height = height / (factor_step_max * 7 + 2);

	if (card_height > max_card_height) {
		card_height = Math.round(max_card_height);
		card_width = Math.round(card_height * factor_width);
		card_spacing = Math.round(card_width * (factor_spacing / 2));
		card_step = Math.round(card_height * factor_step_max);
	}

	start_x = Math.round((width - ((card_width + card_spacing) * 7)) / 2);
}

function redraw_image(name) {
	if (images_canvas[name] === undefined) {
		images_canvas[name] = document.createElement('canvas');
	}

	images_canvas[name].width = card_width;
	images_canvas[name].height = card_height;
	const image_ctx = images_canvas[name].getContext('2d');
	image_ctx.clearRect(0, 0, card_width, card_height);
	image_ctx.drawImage(images[name], 0, 0, card_width, card_height);
}

function draw() {
	needs_redraw = false;

	ctx.fillStyle = 'rgb(0, 80, 0)';
	ctx.fillRect(0, 0, width, height);

	if (stock.length) {
		ctx.drawImage(images_canvas.back_red, start_x, card_spacing);
	}

	if (waste.length) {
		const card = waste[waste.length - 1];
		ctx.drawImage(images_canvas[card.name], start_x + card_width + card_spacing, card_spacing);
	}

	for (let i = 0; i < foundations.length; i++) {
		const x = start_x + (card_width + card_spacing) * (i + 3);

		if (foundations[i].length) {
			const card = foundations[foundations.length - 1];
			ctx.drawImage(images_canvas[card.name], x, card_spacing);
		} else {
			ctx.globalAlpha = 0.1;
			ctx.drawImage(images_canvas.card_base, x, card_spacing);
			ctx.globalAlpha = 1;
		}
	}

	for (let i = 0; i < piles.length; i++) {
		const x = start_x + (card_width + card_spacing) * i;

		for (let j = 0; j < piles[i].length; j++) {
			const y = card_height + card_spacing * 2 + card_step * j;
			const card = piles[i][j];
			const image_name = card.turnedup ? card.name : 'back_red';
			ctx.drawImage(images_canvas[image_name], x, y);
		}
	}

	if (needs_redraw) {
		window.requestAnimationFrame(draw);
	}
}
</script>
</body>
</html>

