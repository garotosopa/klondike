<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Klondike</title>
<link rel="manifest" href="manifest.json">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="msapplication-starturl" content="/klondike/">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="apple-touch-icon" sizes="57x57" href="icons/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="icons/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="icons/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="icons/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="icons/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="icons/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="icons/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="icons/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="icons/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="icons/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="icons/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
<meta name="msapplication-TileColor" content="#005000">
<meta name="msapplication-TileImage" content="icons/ms-icon-144x144.png">
<meta name="theme-color" content="#005000">
<style>
html, body, canvas {
    box-sizing: border-box;
}

html, body {
    width: 100vw;
    height: 100vh;
    margin: 0;
    padding: 0;
}

body {
	background-color: rgb(0, 80, 0);
}

canvas {
	display: block;
}
</style>
</head>
<body>
<!-- bump -->
<canvas id="canvas"></canvas>
<script>
if ('serviceWorker' in navigator) {
	window.addEventListener('load', function () {
		navigator.serviceWorker.register('sw.js').then(function(registration) {
			console.log('ServiceWorker registration successful with scope: ', registration.scope);
		}, function(err) {
			console.log('ServiceWorker registration failed: ', err);
		});
	});
}
</script>
<script>
/**
 * Globals
 */

const cards = [];
['club', 'diamond', 'heart', 'spade'].forEach(suit => {
	for (let i = 1; i <= 13; i++) {
		cards.push(`${suit}_${i}`);
	}
});

const image_names = ['back_red', 'card_base', ...cards];
let image_queue = image_names.length;
const images = {};
const images_canvas = {};

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let width;
let height;
let card_width;
let card_height;
let card_spacing;
let card_step;
let pile_step = [0, 0, 0, 0, 0, 0, 0];

let dragging = {
	what: null,
	x_offset: 0,
	y_offset: 0,
	pile: null,
	step: null,
	foundation: null,
};

let x_start;
let y_start;
let x_stock;
let y_stock;
let x_waste;
let y_waste;
let x_foundations;
let y_foundations;
let x_piles;
let y_piles;

let needs_redraw = true;

const stock = [];
const waste = [];
const foundations = [[], [], [], []];
const piles = [[], [], [], [], [], [], []];

/**
 * Init
 */

recalculate_sizes();

window.addEventListener("resize", function () {
	recalculate_sizes();
	image_names.forEach(redraw_image);
	needs_redraw = true;

	if (!image_queue) {
		window.requestAnimationFrame(draw);
	}
});

window.addEventListener("keydown", function (e) {
	if (e.altKey && e.code === "KeyN") {
		new_game();
		window.requestAnimationFrame(draw);
	}
});

window.addEventListener("click", function (e) {
	if (clicked_inside(e, x_stock, card_width, y_stock, card_height)) {
		pick_stock();
	}
});

window.addEventListener("mousedown", handle_drag_event);
window.addEventListener("touchstart", handle_drag_event, { passive: false });
window.addEventListener("mouseup", handle_drop_event);
window.addEventListener("touchend", handle_drop_event);

image_names.forEach(name => {
	images[name] = new Image();
	images[name].src = `cards/${name}.png`;
	images[name].addEventListener('load', () => {
		--image_queue;
		redraw_image(name);

		if (!image_queue) {
			new_game();
			window.requestAnimationFrame(draw);
		}
	});
	images[name].addEventListener('error', (er) => {
		throw er;
	});
});

cards.forEach(name => {
	stock.push({
		name: name,
		suit: name.split('_')[0],
		number: Number.parseInt(name.split('_')[1]),
		turnedup: false,
	});
});

/**
 * Functions
 */

function new_game()
{
	while (waste.length) {
		stock.push(waste.pop());
	}

	for (let i = 0; i < piles.length; i++) {
		while (piles[i].length) {
			stock.push(piles[i].pop());
		}
	}

	for (let i = 0; i < foundations.length; i++) {
		while (foundations[i].length) {
			stock.push(foundations[i].pop());
		}
	}

	stock.forEach(card => card.turnedup = false);

	for (let i = stock.length; i >= 1; i--) {
		const r = Math.floor(Math.random() * i);
		[stock[i - 1], stock[r]] = [stock[r], stock[i - 1]];
	}

	for (let i = 0; i < piles.length; i++) {
		for (let j = i; j < piles.length; j++) {
			piles[j].push(stock.pop());
		}

		piles[i][i].turnedup = true;
	}

	pile_step.forEach((_, p) => recalculate_pile_step(p));
}

function pick_stock() {
	if (stock.length) {
		waste.push(stock.pop());
		waste[waste.length - 1].turnedup = true;
		window.requestAnimationFrame(draw);
	} else if (waste.length) {
		while(waste.length) {
			stock.push(waste.pop());
			stock[stock.length - 1].turnedup = false;
		}
		window.requestAnimationFrame(draw);
	}
}

function event_position(event) {
	return {
		x: event.changedTouches ?
		   event.changedTouches[0].clientX :
		   event.clientX,
		y: event.changedTouches ?
		   event.changedTouches[0].clientY :
		   event.clientY,
	};
}

function handle_drag_event(event) {
	if (dragging.what) {
		return;
	}

	drag_from_pile(event) ||
		drag_from_waste(event) ||
		drag_from_foundation(event);

	if (dragging.what) {
		event.preventDefault();
		track_movement(event);
		window.addEventListener("mousemove", track_movement);
		window.addEventListener("touchmove", track_movement);
	}
}

function handle_drop_event(event) {
	if (dragging.what) {
		window.removeEventListener("mousemove", track_movement);
		window.removeEventListener("touchmove", track_movement);

		drop_into_pile(event) ||
			drop_into_foundation(event);
	}

	dragging.what = null;
	window.requestAnimationFrame(draw);
}

function drag_from_pile(event) {
	const pos = event_position(event);

	if (pos.y < y_piles) {
		return false;
	}

	const p = x_to_pile(pos.x);
	if (p === undefined) {
		return false;
	}

	if (piles[p].length) {
		const x_pile = x_piles + (card_width + card_spacing) * p;
		let y_step;
		let s;

		if (pos.y < y_piles + pile_step[p] * piles[p].length) {
			s = Math.floor((pos.y - y_piles) / pile_step[p]);
			y_step = y_piles + pile_step[p] * s;
		} else {
			y_step = y_piles + pile_step[p] * (piles[p].length - 1);
			if (clicked_inside(event, x_pile, card_width, y_step, card_height)) {
				s = piles[p].length - 1;
			}
		}

		if (piles[p][s] === undefined || !piles[p][s].turnedup) {
			return false;
		}

		dragging.step = s;
		dragging.x_offset = pos.x - x_pile;
		dragging.y_offset = pos.y - y_step;
	}

	dragging.what = 'pile';
	dragging.pile = p;

	return true;
}

function drop_into_pile(event) {
	const pos = event_position(event);

	if (pos.y < y_piles) {
		return false;
	}

	const p = x_to_pile(pos.x);

	if (p === undefined) {
		return false;
	}

	const x = x_piles + (card_width + card_spacing) * p;
	const y = y_piles + pile_step[p] * (piles[p].length ? piles[p].length - 1 : 0);
	const table_card = piles[p][piles[p].length - 1];

	if (!clicked_inside(event, x, card_width, y, card_height)) {
		return false;
	}

	if (dragging.what === 'waste') {
		const card = waste[waste.length - 1];
		if (can_drop_below(table_card, card)) {
			piles[p].push(waste.pop());
			recalculate_pile_step(p);
		}
	} else if (dragging.what === 'pile') {
		const card = piles[dragging.pile][dragging.step];
		if (can_drop_below(table_card, card)) {
			const hand = piles[dragging.pile].splice(
				dragging.step,
				piles[dragging.pile].length - dragging.step
			);

			for (let i = 0; i < hand.length; i++) {
				piles[p].push(hand[i]);
			}

			if (piles[dragging.pile].length) {
				piles[dragging.pile][piles[dragging.pile].length - 1].turnedup = true;
			}

			recalculate_pile_step(p);
			recalculate_pile_step(dragging.pile);
		}
	} else if (dragging.what === 'foundation') {
		const card = foundations[dragging.foundation][foundations[dragging.foundation].length - 1];
		if (can_drop_below(table_card, card)) {
			piles[p].push(foundations[dragging.foundation].pop());
			recalculate_pile_step(p);
		}
	}
}

function drag_from_waste(event) {
	if (!waste.length || !clicked_inside(event, x_waste, card_width, y_waste, card_height)) {
		return false;
	}

	const pos = event_position(event);
	dragging.what = 'waste';
	dragging.x_offset = pos.x - x_waste;
	dragging.y_offset = pos.y - y_waste;

	return true;
}

function drag_from_foundation(event) {
	if (!clicked_inside(event, x_foundations, (card_width + card_spacing) * 4, y_foundations, card_height)) {
		return false;
	}

	const pos = event_position(event);
	const f = x_to_foundation(pos.x);

	if (f === undefined || !foundations[f].length) {
		return false;
	}

	dragging.what = 'foundation';
	dragging.foundation = f;
	dragging.x_offset = pos.x - (x_foundations + (card_width + card_spacing) * f);
	dragging.y_offset = pos.y - y_foundations;
}

function drop_into_foundation(event) {
	if (!clicked_inside(event, x_foundations, (card_width + card_spacing) * 4, y_foundations, card_height)) {
		return false;
	}

	const pos = event_position(event);
	const f = x_to_foundation(pos.x);

	if (f === undefined) {
		return false;
	}

	const table_card = foundations[f][foundations[f].length - 1];

	if (dragging.what === 'waste') {
		const card = waste[waste.length - 1];
		if (can_drop_on(table_card, card)) {
			foundations[f].push(waste.pop());
		}
	} else if (dragging.what === 'pile') {
		if (dragging.step !== piles[dragging.pile].length - 1) {
			return false;
		}

		const card = piles[dragging.pile][dragging.step];
		if (can_drop_on(table_card, card)) {
			foundations[f].push(piles[dragging.pile].pop());
			if (piles[dragging.pile].length) {
				piles[dragging.pile][piles[dragging.pile].length - 1].turnedup = true;
			}
			recalculate_pile_step(dragging.pile);
		}
	} else if (dragging.what === 'foundation') {
		const card = foundations[dragging.foundation][foundations[dragging.foundation].length - 1];
		if (can_drop_on(table_card, card)) {
			foundations[f].push(foundations[dragging.foundation].pop());
		}
	}

	return true;
}

function clicked_inside(event, x, w, y, h) {
	const pos = event_position(event);
	return pos.x >= x &&
	       pos.x <= x + w &&
	       pos.y >= y &&
	       pos.y <= y + h;
}

function x_to_foundation(x) {
	const f = Math.floor((x - x_foundations) / (card_width + card_spacing));
	const max_x = x_foundations + (card_width + card_spacing) * f + card_width;

	if (f >= 0 && f < 4 && x <= max_x) {
		return f;
	}
}

function x_to_pile(x) {
	const p = Math.floor((x - x_piles) / (card_width + card_spacing));
	const max_x = x_piles + (card_width + card_spacing) * p + card_width;

	if (p >= 0 && p < 7 && x <= max_x) {
		return p;
	}
}

function card_color(card)
{
	if (card.suit === 'club' || card.suit === 'spade') {
		return 'black';
	}

	if (card.suit === 'heart' || card.suit === 'diamond') {
		return 'red';
	}
}

function can_drop_below(table_card, hand_card)
{
	if (table_card === undefined || !table_card.turnedup) {
		return hand_card.number === 13;
	} else {
		return card_color(table_card) !== card_color(hand_card)
			   && table_card.number === (hand_card.number + 1);
	}
}

function can_drop_on(table_card, hand_card)
{
	if (table_card === undefined) {
		return hand_card.number === 1;
	} else {
		return table_card.suit === hand_card.suit
		       && table_card.number === (hand_card.number - 1);
	}
}

function track_movement(event) {
	if (dragging.what) {
		const pos = event_position(event);
		dragging.x = pos.x;
		dragging.y = pos.y;
	}

	window.requestAnimationFrame(draw);
}

function recalculate_sizes() {
	width = document.body.clientWidth;
	height = document.body.clientHeight;
	canvas.width = width;
	canvas.height = height;

	const factor_spacing = 0.1;
	const factor_width = 0.69;
	const factor_height = 1.45;
	const factor_step_max = 0.165;

	card_width = Math.round(width / 7 * (1 - factor_spacing));
	card_height = Math.round(card_width * factor_height);
	card_spacing = Math.round(card_width * (factor_spacing / 2));
	card_step = Math.round(card_height * factor_step_max);

	const max_card_height = height / (factor_step_max * 7 + 2);

	if (card_height > max_card_height) {
		card_height = Math.round(max_card_height);
		card_width = Math.round(card_height * factor_width);
		card_spacing = Math.round(card_width * (factor_spacing / 2));
		card_step = Math.round(card_height * factor_step_max);
	}

	x_start = Math.round((width - ((card_width + card_spacing) * 7)) / 2);
	y_start = card_spacing;
	x_stock = x_start;
	y_stock = y_start;
	x_waste = x_start + card_width + card_spacing;
	y_waste = card_spacing;
	x_foundations = x_start + (card_width + card_spacing) * 3;
	y_foundations = card_spacing;
	x_piles = x_start;
	y_piles = card_height + card_spacing * 2;

	pile_step.forEach((_, p) => recalculate_pile_step(p));
}

function recalculate_pile_step(p)
{
	if (piles[p].length) {
		const max_pile_step = Math.floor((height - y_piles - card_height - card_spacing) / (piles[p].length - 1));
		pile_step[p] = max_pile_step > card_step ? card_step : max_pile_step;
	} else {
		pile_step[p] = card_step;
	}
}

function redraw_image(name) {
	if (images_canvas[name] === undefined) {
		images_canvas[name] = document.createElement('canvas');
	}

	images_canvas[name].width = card_width;
	images_canvas[name].height = card_height;
	const image_ctx = images_canvas[name].getContext('2d');
	image_ctx.clearRect(0, 0, card_width, card_height);
	image_ctx.drawImage(images[name], 0, 0, card_width, card_height);
}

function draw() {
	needs_redraw = false;

	ctx.fillStyle = 'rgb(0, 80, 0)';
	ctx.fillRect(0, 0, width, height);

	if (stock.length) {
		ctx.drawImage(images_canvas.back_red, x_stock, y_stock);
	} else {
		ctx.globalAlpha = 0.1;
		ctx.drawImage(images_canvas.card_base, x_stock, y_stock);
		ctx.globalAlpha = 1;
	}

	if (waste.length) {
		let card;
		if (dragging.what === 'waste') {
			if (waste.length > 1) {
				card = waste[waste.length - 2];
			}
		} else {
			card = waste[waste.length - 1];
		}

		if (card) {
			ctx.drawImage(images_canvas[card.name], x_waste, y_waste);
		}
	}

	for (let f = 0; f < foundations.length; f++) {
		const x = x_foundations + (card_width + card_spacing) * f;
		const i = dragging.what === 'foundation' && dragging.foundation === f
		        ? foundations[f].length - 2
		        : foundations[f].length - 1;

		if (i >= 0) {
			const card = foundations[f][i];
			ctx.drawImage(images_canvas[card.name], x, y_foundations);
		} else {
			ctx.globalAlpha = 0.1;
			ctx.drawImage(images_canvas.card_base, x, y_foundations);
			ctx.globalAlpha = 1;
		}
	}

	for (let p = 0; p < piles.length; p++) {
		const x = x_start + (card_width + card_spacing) * p;

		for (let s = 0; s < piles[p].length; s++) {
			if (dragging.what === 'pile' && dragging.pile === p && dragging.step === s) {
				break;
			}

			const y = y_piles + pile_step[p] * s;
			const card = piles[p][s];
			const image_name = card.turnedup ? card.name : 'back_red';
			ctx.drawImage(images_canvas[image_name], x, y);
		}
	}

	if (dragging.what === 'waste') {
		const card = waste[waste.length - 1];
		ctx.drawImage(
			images_canvas[card.name],
			dragging.x - dragging.x_offset,
			dragging.y - dragging.y_offset
		);
	} else if (dragging.what === 'pile') {
		for (let s = dragging.step; s < piles[dragging.pile].length; s++) {
			const card = piles[dragging.pile][s];
			ctx.drawImage(
				images_canvas[card.name],
				dragging.x - dragging.x_offset,
				dragging.y - dragging.y_offset + pile_step[dragging.pile] * (s - dragging.step)
			);
		}
	} else if (dragging.what === 'foundation') {
		const card = foundations[dragging.foundation][foundations[dragging.foundation].length - 1];
		ctx.drawImage(
			images_canvas[card.name],
			dragging.x - dragging.x_offset,
			dragging.y - dragging.y_offset
		);
	}

	if (needs_redraw) {
		window.requestAnimationFrame(draw);
	}
}
</script>
</body>
</html>

